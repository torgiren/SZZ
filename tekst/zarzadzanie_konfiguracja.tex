\chapter{Zarządzanie konfiguracją}
W rozdziale tym przedstawię różne metody zarządzania konfiguracją serwerów. Postaram się opisać poglądowo różne metody, jak również przedstawić zalety i wady poszczególnych z nim.
\section{Ręczna konfiguracja każdego serwera za pomocą SSH}
\subsection{Opis}
Ręczna konfiguracja serwerów stos osuwana jest głównie tam, gdzie administrator ma pod swoją opieką jeden bądź kilka serwerów. W takim przypadku zmiana konfiguracji na serwerze jest prosta i nie zajmuje dużej ilości czasu.\\
Konfiguracja taka nie wymaga od administratora żadnej wiedzy wykraczającej poza obszar konfigurowanego systemu oraz usług, a wprowadzane zmiany widoczne są od razu po wprowadzeniu.
Ten sposób konfiguracji spotykany jest czasem w większych systemach informatycznych.
Dzieje się tak zwykle w jednostkach szybko rozwijających się, gdzie nastąpił szybki wzrost liczby serwerów i nie opracowano jeszcze metoda automatyzacji konfiguracji.

Do konfiguracji ręcznej nie potrzeba żadnego dodatkowego oprogramowania ani po stronie maszyn konfigurowanych, ani maszyny z której następuje konfiguracja.
Na maszynie z której następuje konfiguracja musi być dostępny klient SSH, który jest instalowany domyślnie we wszystkich dystrybucjach systemów GNU/Linux, a na maszynach konfigurowanych musi być zainstalowany i uruchomiony serwer SSH - jest on domyślnie zainstalowany w większości dystrybucji serwerowych GNU/Linux i w części dystrybucji przeznaczonych na komputery domowe.

Wadą takiej metody jest również sytuacja, w której tylko jedna osoba, bądź mała grupa osób, zna konfigurację poszczególnych serwerów oraz usług.
W przypadku opuszczenia przez daną osobę zespołu, pozostali członkowie muszą, analizując pliki konfiguracyjne, zrozumieć zamysł osoby to tworzącej.\\
Kolejną wadą, jest brak możliwości powielenia konfiguracji.
W przypadku gdy zaistnieje potrzeba skonfigurowania bliźniaczego serwera, jako serwera zapasowego, należy każdą usługę skonfigurować od nowa na wzór serwera pierwotnego. Również wprowadzane zmiany należy uwzględniać na wszystkich serwerach.
Może to w prosty sposób prowadzić do błędów i rozbieżności konfiguracji.
\subsection{Zalety i wady}
Zalety:
\begin{itemize}
\item prostota
\item używanie tylko domyślnych komponentów systemu
\item szybkość wprowadzanych zmian
\item informacja zwrotna czy usługa została uruchomiona poprawnie
\end{itemize}
Wady:
\begin{itemize}
\item \textbf{brak skalowalności}
\item różnice między poszczególnymi serwerami
\item trudność powielania
\item wiedza o konfiguracji zależna od jednego pracownika
\end{itemize}
\subsection{Przykład}
\lstinputlisting{lst/conf_ssh.sh}
\subsection{CSSH}
Istnieje narzędzie CSSH (\textit{Cluster SSH}) które wychodzi na przeciw osobą chcącym konfigurować kilka serwerów jednocześnie poprzez SSH.
Narzędzie to potrafi otworzyć wiele sesji SSH równolegle - każda sesja w osobnym terminalu.
Głównym interface-em programu, jest małe okno wejścia, które przechwytując wpisywany do niego tekst, przesyła go do wszystkich otwartych sesji.\\
Zmniejsza to prawdopodobieństwo rozbieżności w konfiguracji, jak również przyśpiesza proces, ponieważ tekst jest wpisywany do wszystkich sesji jednocześnie i nie ma potrzeby wielokrotnego wpisywania tej samej konfiguracji na wielu maszynach.\\
Aplikacja umożliwia również przełączenie się w dowolnej chwili na konkretny terminal i interakcję tylko z jednym serwerem, np: w celu zdiagnozowania problemu występującego tylko na tej jednej maszynie.
\section{Fabric}
\subsection{Opis}
Jest aplikacją napisaną w języku Python, służącą głównie do wykonywania poleceń powłoki na zdalnym serwerze. Aplikacja pozwala na zdefiniowanie kolejności w jakiej mają zostać poszczególne polecenia, jak również udostępnia kilka funkcji sprawdzających, np: czy plik istnieje, bądź kopiowanie plików na lub z serwera.\\
Sprawdza się wszędzie tam, gdzie chcemy wykonać konkretne operacje na zdalnym systemie niezależnie od aktualnego stanu tego systemu, bądź z niewielkim wpływem obecnych czynników.
Zastosowanie fabrica można porównać do CSSH, z tą różnicą, że operacje nie są wpisywane przez administratora podczas sesji, a zdefiniowane wcześniej w pliku, co w znacznym stopniu ułatwia powtarzalność wykonywania zdefiniowanych operacji.
Pozwala również w prosty sposób rozdzielić zdefiniowane zadania na poszczególne grupy serwerów na których należy je wykonać.\\
Typowe zastosowania:
\begin{itemize}
\item restart nietypowych usług nie posiadających jeszcze odpowiednich skryptów sysvinit
\item rekonfiguracja projektów na zdalnych serwerach po wysłaniu zmian przez system kontroli wersji
\item przeszukiwanie logów poszczególnych serwerów
\end{itemize}
\subsection{Zalety i wady}
Zalety:
\begin{itemize}
\item łatwość instalacji - repozytoria dystrybucji oraz pythonowe
\item równoległe wykonywanie operacji
\item łatwość konfiguracji
\item powtarzalność wykonywania
\item skalowalność
\item niewymagana instalacja oprogramowania na zdalnych maszynach
\end{itemize}
Wady:
\begin{itemize}
\item ograniczone możliwości decyzji na podstawie aktualnej konfiguracji
\item wykonywanie tylko poleceń powłoki
\end{itemize}
\subsection{Przykład}
\lstinputlisting[language=python,caption=fabfile.py]{lst/conf_fabfile.py}
przykład działania powyższego skryptu:
\lstinputlisting{lst/conf_fabfile_run.sh}
Aplikacja została uruchomiona z parametrami:
\begin{description}
\item[-P] równolegle wykonywanie zadań
\item[-z 5] uruchomienie pięciu równoległych połączeń
\item[-I] zapytanie o hasło do serwerów (używane gdy niedostępne logowanie po kluczach SSH)
\item[show\_problem] nazwa zadania zdefiniowana w pliku \texttt{fabfile.py}
\end{description}
Fabric wykonuje połączenia do hostów zdefiniowanych w zmiennej \texttt{env.hosts} w liczbie pięciu połączeń równoległych.
W przypadku nie podania parametru \texttt{-z}, aplikacja wykona liczbę równoległych połączeń równą liczbie zdefiniowanych hostów dla danego zadania.\\
Po połączeniu się do zdalnego hosta, następuje sprawdzenie czy istnieje plik \texttt{/var/problem}. W przypadku wykrycia istnienia takiego pliku, zostaje wywołane polecenie powłoki \texttt{cat}.
W wyniku wykonywania widzimy, ze plik \texttt{/var/problem} istniał tylko na serwerze o adresie IP \texttt{192.168.0.12} i zawierał tekst \textit{zasob byl podmontowany}.
\section{Puppet}
Aż się nie chce tego tykać
\section{Chef}
Tego też
\section{CFEngine3}
O tym może coś napiszę jak doczytam
\section{Ansible}
\subsection{Opis}
Ansible jest również narzędziem do zarządzania konfiguracja serwerów. Został napisany w języku Python i w przeciwieństwie do poprzedników nie wymaga instalacji żadnego oprogramowania na maszynach klienckich.
Wymaga jedynie, aby na maszynach które będą miały być obsługiwane przez Ansible, był zainstalowany serwer SSH oraz interpreter języka Python. Obie te rzeczy są instalowany domyślnie przez znaczna większość dystrybucji.
Zalecane jest również skonfigurowanie logowania przy użyciu kluczy SSH, jednak wpływa to tylko na bezpieczeństwo i wygodę użytkowania.\\
\subsubsection{Tryb aktywny i pasywny}
Inną cechą odróżniającą Ansible od jego alternatyw jest kierunek działania.
Ansible jest system działającym w trybie aktywnym, natomiast Puppet, Chef bądź CFEngine działają pasywnie.
Znaczy to, że działanie Ansible jest wymuszane przez administratora poprzez wywołanie odpowiedniego \textit{playbooka}, w przeciwieństwie do pozostałych, gdzie demon działający na serwerze klienckim odpytuje serwer z konfiguracją w celu pobrania aktualnych polityk.
Ansible tutaj daje administratorowi większe pole do działania, ponieważ, po wykonaniu \textit{playbook}-a dostaje on raport, jakie kroki zostały podjęte, które polityki były spełnione a które nie, oraz czy jakieś akcje się nie powiodły.\\
Pozwala on również w prosty sposób na konfigurację działania w trybie quasi-pasywnym poprzez zastosowanie np: \textit{cron}-a do cyklicznego wykonywania \textit{playbook}-a.
W efekcie Ansible daje możliwość pracy w trybie aktywnym jak i pasywnym.
\subsubsection{Instalacja}
Istnieje kilka metod instalacji Ansible
\begin{itemize}
\item ze źródeł\\
Jest to najprostsza metoda instalacji. Ponieważ Ansible jest napisane w języku Python, nie wymaga on kompilacji ani ingerencji w system.
\lstinputlisting{lst/ansible_install_git.sh}
Metoda ta wymaga jednak aby w systemie zainstalowane były biblioteki Pythonowe:
\begin{itemize}
\item paramiko
\item PyYAML
\item jinja2
\item httplib2
\end{itemize}
Wykonanie powyższego kodu powoduje przełączenie się na wirtualne środowisko Pythona przygotowane przez developerów Ansible.\\
Wirtualne środowisko zostanie opisane w kolejnym podrozdziale.
\item przez repozytorium\\
Ansible jest obecne w repozytorium praktycznie każdej dystrybucji. Instalacja zależna jest od konkretnej dystrybucji.\\
Ta metoda może powodować problemy z używaniem Ansible w wirtualnym środowisku Pythona ponieważ narzędzie instalowane jest globalnie, natomiast środowisko wirtualne często tworzone jest bez dostępu do globalnych bibliotek.
\item przez PIP\\
Jest to zalecana metoda instalacji, ponieważ łączy w sobie prostotę procesu z elastycznością.
Wykorzystuje on repozytorium bibliotek Pythonowych - \texttt{pip}.\\
Instalacja Ansible poprzez \texttt{pip} wymaga wykonania polecenia:\\
\lstinputlisting{lst/ansible_install_pip.sh}
spowoduje ono ściągnięcie najnowszej wersji Ansible jak również zależnych pakietów.
Instalacja odbędzie się do katalogów zdefiniowanych w zmiennych środowiskowych. Domyślnie są do główne katalogi \texttt{/usr} jednak mogą one zostać nadpisane przez użycie wirtualnego środowiska.
\end{itemize}
\subsubsection{Wirtualne środowisko Pythonowe}
Wirtualne środowisko jest narzędziem pozwalającym na stworzenie odizolowanego od bibliotek systemowych środowiska uruchomieniowego dla aplikacji pythonowych.\\
Nowe środowisko tworzone jest przy pomocy polecenia \texttt{virtualenv}.
Tworzy ono strukturę katalogów potrzebną interpreterowi Pythona do działania. Poniżej znajduje się przykład takiej struktury:
\lstinputlisting{lst/ansible_install_tree.sh}
Poleceniem \texttt{source <plik\_aktywacji>} aktywujemy wirtualne środowisko.
Powoduje to nadpisanie domyślnych ścieżek przeszukiwania z domyślnych systemowych na lokalne w wirtualnym środowisku.
Następnie należy uruchamiać interpreter Pythona nie podając bezpośredniej ścieżki do niego (np: \texttt{/usr/bin/python2}) lecz poprzez zmodyfikowane środowisko: \texttt{/usr/bin/env python}.
Pozwala to ...różne wersje pythona i przenoścność...
\subsubsection{Moduły}
Ansible wyposażony jest w dużą gamę gotowych
