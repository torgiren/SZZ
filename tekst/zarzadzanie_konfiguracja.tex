\chapter{Zarządzanie konfiguracją}
W rozdziale tym przedstawię różne metody zarządzania konfiguracją serwerów. Postaram się opisać poglądowo różne metody, jak również przedstawić zalety i wady każdej z nich.
\section{Ręczna konfiguracja każdego serwera za pomocą SSH}
\subsection{Opis}
Ręczna konfiguracja serwerów stososuwana jest głównie tam, gdzie administrator ma pod swoją opieką jeden bądź kilka serwerów. W takim przypadku zmiana konfiguracji na serwerze jest prosta i nie zajmuje dużo czasu.

Konfiguracja taka nie wymaga od administratora żadnej wiedzy wykraczającej poza obszar konfigurowanego systemu oraz usług, a zmiany widoczne są od razu po ich wprowadzeniu.
Ten sposób konfiguracji spotykany jest czasem w większych systemach informatycznych.
Dzieje się tak zwykle w jednostkach szybko rozwijających się, gdzie nastąpił znaczny wzrost liczby serwerów i nie opracowano jeszcze metody automatyzacji konfiguracji.

Do konfiguracji ręcznej nie potrzeba żadnego dodatkowego oprogramowania ani po stronie maszyn konfigurowanych, ani maszyny, z której następuje konfiguracja.
Na maszynie, z której następuje konfiguracja musi być dostępny klient SSH, który jest instalowany domyślnie we wszystkich dystrybucjach systemów GNU/Linux, a na maszynach konfigurowanych musi być zainstalowany i uruchomiony serwer SSH. Jest on domyślnie zainstalowany w większości dystrybucji serwerowych GNU/Linux i w części dystrybucji przeznaczonych na komputery domowe.

Wadą takiej metody jest sytuacja, w której tylko jedna osoba, bądź mała grupa osób, zna konfigurację poszczególnych serwerów oraz usług.
W przypadku opuszczenia przez daną osobę zespołu, pozostali członkowie muszą, analizując pliki konfiguracyjne, zrozumieć zamysł osoby to tworzącej.

Kolejną wadą jest brak możliwości powielenia konfiguracji.
W przypadku, gdy zaistnieje potrzeba skonfigurowania bliźniaczego serwera, jako serwera zapasowego, należy każdą usługę skonfigurować od nowa na wzór serwera pierwotnego. Również wprowadzane zmiany należy uwzględniać na wszystkich serwerach.
Może to w prosty sposób prowadzić do błędów i rozbieżności konfiguracji.
\subsection{Zalety i wady}
Zalety:
\begin{itemize}
\item prostota;
\item używanie tylko domyślnych komponentów systemu;
\item szybkość wprowadzanych zmian;
\item informacja zwrotna czy usługa została uruchomiona poprawnie.
\end{itemize}
Wady:
\begin{itemize}
\item \textbf{brak skalowalności};
\item różnice między poszczególnymi serwerami;
\item trudność powielania;
\item wiedza o konfiguracji zależna od jednego pracownika.
\end{itemize}
\subsection{Przykład}
\lstinputlisting{lst/conf_ssh.sh}
\subsection{CSSH}
Istnieje narzędzie CSSH (\textit{Cluster SSH}), które wychodzi na przeciw osobom chcącym konfigurować kilka serwerów jednocześnie poprzez SSH.
Narzędzie to potrafi otworzyć wiele sesji SSH równolegle (każda sesja w osobnym terminalu).
Głównym interfacem programu jest małe okno wejścia, które przechwytując wpisywany do niego tekst, przesyła go do wszystkich otwartych sesji.
Zmniejsza to prawdopodobieństwo rozbieżności w konfiguracji, jak również przyśpiesza proces, ponieważ tekst jest wpisywany do wszystkich sesji jednocześnie i nie ma potrzeby wielokrotnego wpisywania tej samej konfiguracji na wielu maszynach.
Aplikacja umożliwia również przełączenie się w dowolnej chwili na konkretny terminal i interakcję tylko z jednym serwerem, np: w celu zdiagnozowania problemu występującego tylko na tej jednej maszynie.
\section{Fabric}
\subsection{Opis}
\textit{Fabric} jest aplikacją napisaną w języku Python służącą głównie do wykonywania poleceń powłoki na zdalnym serwerze. Aplikacja ta pozwala na zdefiniowanie kolejności w jakiej mają występować poszczególne polecenia, jak również udostępnia kilka funkcji sprawdzających, np: czy plik istnieje, bądź kopiowanie plików na serwer lub z serwera.
Aplikacja sprawdza się wszędzie tam, gdzie chcemy wykonać konkretne operacje na zdalnym systemie niezależnie od aktualnego stanu tego systemu, bądź z niewielkim wpływem obecnych czynników.
Zastosowanie \textit{fabrica} można porównać do CSSH, z tą różnicą, że operacje nie są wpisywane przez administratora podczas sesji, a zdefiniowane wcześniej w pliku, co w znacznym stopniu ułatwia powtarzalność wykonywania zdefiniowanych operacji.
Pozwala również w prosty sposób rozdzielić zdefiniowane zadania na poszczególne grupy serwerów, na których należy je wykonać.\\
Typowe zastosowania:
\begin{itemize}
\item restart nietypowych usług nieposiadających jeszcze odpowiednich skryptów \textit{sysvinit};
\item rekonfiguracja projektów na zdalnych serwerach po wysłaniu zmian przez system kontroli wersji;
\item przeszukiwanie logów poszczególnych serwerów.
\end{itemize}
\subsection{Zalety i wady}
Zalety:
\begin{itemize}
\item łatwość instalacji - repozytoria dystrybucji oraz repozytoria pythonowe;
\item równoległe wykonywanie operacji;
\item łatwość konfiguracji;
\item powtarzalność wykonywania;
\item skalowalność;
\item niewymagana instalacja oprogramowania na zdalnych maszynach.
\end{itemize}
Wady:
\begin{itemize}
\item ograniczone możliwości decyzji na podstawie aktualnej konfiguracji;
\item wykonywanie tylko poleceń powłoki.
\end{itemize}
\subsection{Przykład}
\lstinputlisting[language=python,caption=fabfile.py]{lst/conf_fabfile.py}
przykład działania powyższego skryptu:
\lstinputlisting{lst/conf_fabfile_run.sh}
Aplikacja została uruchomiona z parametrami:
\begin{description}
\item[-P] równolegle wykonywanie zadań;
\item[-z 5] uruchomienie pięciu równoległych połączeń;
\item[-I] zapytanie o hasło do serwerów (używane, gdy niedostępne jest logowanie po kluczach SSH);
\item[show\_problem] nazwa zadania zdefiniowana w pliku \texttt{fabfile.py}.
\end{description}
\textit{Fabric} wykonuje połączenia do hostów zdefiniowanych w zmiennej \texttt{env.hosts} w liczbie pięciu połączeń równoległych.
W przypadku niepodania parametru \texttt{-z} aplikacja wykona liczbę równoległych połączeń równą liczbie zdefiniowanych hostów dla danego zadania.

Po połączeniu się do zdalnego hosta, następuje sprawdzenie czy istnieje plik \texttt{/var/problem}. W przypadku wykrycia istnienia takiego pliku, zostaje wywołane polecenie powłoki \texttt{cat}.
W wyniku wykonywania widzimy, ze plik \texttt{/var/problem} istniał tylko na serwerze o adresie IP \texttt{192.168.0.12} i zawierał tekst \textit{zasob byl podmontowany}.
\section{Puppet}
\subsection{Opis}
\label{sec:puppet_opis}
\textit{Puppet} jest jednym z najbardziej rozpowszechnionych systemów do zarządzania konfiguracją.
U podstaw ideologii działania \textit{puppeta} stoi definicja oczekiwanego stanu serwera.
Administrator definiuje oczekiwany stan systemu, np: istnienie użytkownika o podanych parametrach, bądź istnienie pliku o zadanej zawartości, a \textit{puppet} dąży do uzyskania takiego stanu (stworzy użytkownika lub plik taki, aby spełniał zadane wymagania).

\textit{Puppet} został napisany w języku Ruby, co wpływa na składnię manifestów przez niego wykorzystywanych.
Manifest jest opisem żądanego stanu danego obiektu (użytkownik, plik, zamontowany zasób).
Manifesty są zapisywane w plikach \texttt{*.pp}.
\textit{Puppet} działa w trybie klient-serwer.
Serwer posiada zapisane manifesty dla wszystkich maszyn, dlatego w celu rekonfiguracji wielu maszyn wystarczy zmiana jedynie w centralnym punkcie - serwerze \textit{master}.\\
Istnieją trzy możliwości wykonywania manifestów:
\begin{itemize}

	\item{bezpośrednio na maszynie}
		poprzez jawne wywołanie manifestu na danej maszynie. Następuje wtedy sparsowanie manifestu oraz zastosowanie zawartych w nim deklaracji do lokalnej maszyny.
	\item{cykliczne pobieranie danych przez agenta}.
		Z racji tego, że \textit{puppet} w zamyśle ma działać w trybie \textit{pull} jest to jego domyślny tryb pracy.
		Agent działający na maszynach klienckich (maszynach, których stan ma być kontrolowany przez \textit{puppeta}) w cyklicznych odstępach czasu pobiera z serwera \textit{master} żądaną konfiguracje.
		Nie pobiera on bezpośrednio manifestów zapisanych przed administratora, lecz skompilowaną ich wersję specjalne dla tej maszyny.
		
		Połączenia do \textit{mastera} są szyfrowane poprzez SSL, co zwiększa bezpieczeństwo przesyłanych wrażliwych danych zawartych w manifestach.
	\item{wymuszone uruchomienie agenta}.
		Tryb ten działa podobnie do cyklicznego pobierania danych, z tą różnicą, ze użytkownik jawnie zmusza agenta do natychmiastowego pobrania danych z serwera \textit{master}, zamiast czekać aż agent pobierze te dane samoistnie.
\end{itemize}
\subsection{Zalety i wady}
Zalety:
\begin{itemize}
	\item popularność;
	\item duże zaplecze \textit{community};
	\item dojrzałość projektu.
\end{itemize}
Wady:
\begin{itemize}
	\item potrzeba instalacji oprogramowania na maszynach klienckich;
	\item działanie w trybie \textit{pull};
	\item skomplikowana instalacja.
\end{itemize}

\section{CFEngine}
\subsection{Opis}
CFEngine jest jednym z najstarszych systemów do zarządzania konfiguracją.
Powstał z myślą o systemach, w których nie jest zapewniona dostateczna jakoś łącza, np: łodzie podwodne.

Z racji swojego wieku, architektura CFEngine w odpowiedzi na zmieniające się potrzeby systemów, ulegała zmianom.
Aktualnie rozwijana jest trzecia generacja CFEngine.
Kolejne generacje starały się upraszczać składnię konfiguracji oraz zwiększać możliwości oferowane przez oprogramowanie.

CFEngine opiera się na "Teorii obietnic".
Jest to teoria stojąca u podstaw wszystkich systemów zarządzania konfiguracją. W celu opisu teorii obietnic por. z \ref{sec:puppet_opis}.

CFEngine, podobnie jak Puppet działa w trybie \textit{pull}, czyli agent pobiera dane z centralnego serwera.
W przeciwieństwie do Puppeta, CFEngine zapisuje pobrane \textit{polityki} na lokalnej maszynie, dzięki czemu w przypadku braku łącza do maszyny centralnej, jest w stanie kontrolować i ewentualnie korygować konfigurację maszyny w stanie offline.
\subsection{Zalety i Wady}
Zalety:
\begin{itemize}
	\item dojrzałość projektu;
	\item odporność na przerwy w działaniu łącza;
	\item bardzo duża skalowalność.
\end{itemize}
Wady:
\begin{itemize}
	\item trudna konfiguracja;
	\item trudna instalacja.
\end{itemize}
\section{Ansible}
\subsection{Opis}
Ansible jest narzędziem do zarządzania konfiguracją serwerów. Został napisany w języku Python i w przeciwieństwie do poprzedników nie wymaga instalacji żadnego oprogramowania na maszynach klienckich.
Wymaga jedynie, aby na maszynach, które będą obsługiwane przez Ansible, był zainstalowany serwer SSH oraz interpreter języka Python. Obie te rzeczy są instalowane domyślnie przez znaczną większość dystrybucji.
Zalecane jest również skonfigurowanie logowania przy użyciu kluczy SSH, jednak wpływa to tylko na bezpieczeństwo i wygodę użytkowania.\\
\subsubsection{Tryb aktywny i pasywny}
Inną cechą odróżniającą Ansible od innych tego typu narzędzi jest kierunek działania.
Ansible jest system działającym w trybie aktywnym, natomiast Puppet, Chef bądź CFEngine działają pasywnie.
Znaczy to, że działanie Ansible jest wymuszane przez administratora poprzez wywołanie odpowiedniego \textit{playbooka}, w przeciwieństwie do pozostałych, gdzie demon działający na serwerze klienckim odpytuje serwer z konfiguracją w celu pobrania aktualnych polityk.
Ansible daje tutaj administratorowi większe pole do działania, ponieważ po wykonaniu \textit{playbooka} dostaje on raport, jakie kroki zostały podjęte, które polityki były spełnione a które nie oraz czy jakieś akcje się nie powiodły.
Pozwala on również w prosty sposób na konfigurację działania w trybie quasi-pasywnym poprzez zastosowanie np: \textit{crona} do cyklicznego wykonywania \textit{playbooka}.
W efekcie Ansible daje możliwość pracy zarówno w trybie aktywnym, jak i pasywnym.
\subsubsection{Instalacja}
Istnieje kilka metod instalacji Ansible:
\begin{itemize}
\item ze źródeł - jest to najprostsza metoda instalacji. Ponieważ Ansible jest napisane w języku Python, nie wymaga on kompilacji ani ingerencji w system.
\lstinputlisting{lst/ansible_install_git.sh}
Metoda ta wymaga jednak aby w systemie zainstalowane były biblioteki Pythonowe:
\begin{itemize}
\item paramiko
\item PyYAML
\item jinja2
\item httplib2
\end{itemize}
Wykonanie powyższego kodu powoduje przełączenie się na wirtualne środowisko Pythona przygotowane przez developerów Ansible.

Wirtualne środowisko zostanie opisane w kolejnym podrozdziale.
\item przez repozytorium - Ansible jest obecne w repozytorium praktycznie każdej dystrybucji. Instalacja zależna jest od konkretnej dystrybucji.

Ta metoda może powodować problemy z używaniem Ansible w wirtualnym środowisku Pythona, ponieważ narzędzie instalowane jest globalnie, natomiast środowisko wirtualne często tworzone jest bez dostępu do globalnych bibliotek.
\item przez PIP - jest to zalecana metoda instalacji, ponieważ łączy w sobie prostotę procesu z elastycznością.
Wykorzystuje on repozytorium bibliotek Pythonowych - \texttt{pip}.\\
Instalacja Ansible poprzez \texttt{pip} wymaga wykonania polecenia:\\
\lstinputlisting{lst/ansible_install_pip.sh}
Polecenie to spowoduje ściągnięcie najnowszej wersji Ansible, jak również zależnych pakietów.
Instalacja odbędzie się do katalogów zdefiniowanych w zmiennych środowiskowych. Domyślnie są to główne katalogi \texttt{/usr}, jednak mogą one zostać nadpisane przez użycie wirtualnego środowiska.
\end{itemize}
\subsubsection{Wirtualne środowisko Pythonowe}
Wirtualne środowisko jest narzędziem pozwalającym na stworzenie odizolowanego od bibliotek systemowych środowiska uruchomieniowego dla aplikacji pythonowych.

Nowe środowisko tworzone jest przy pomocy polecenia \texttt{virtualenv}.
Tworzy ono strukturę katalogów potrzebną interpreterowi Pythona do działania. Poniżej znajduje się przykład takiej struktury:
\lstinputlisting{lst/ansible_install_tree.sh}
Poleceniem \texttt{source <plik\_aktywacji>} aktywujemy wirtualne środowisko.
Powoduje to nadpisanie domyślnych ścieżek przeszukiwania z domyślnych systemowych na lokalne w wirtualnym środowisku.
Następnie należy uruchamiać interpreter Pythona nie podając bezpośredniej ścieżki do niego (np: \texttt{/usr/bin/python2}), lecz poprzez zmodyfikowane środowisko: \texttt{/usr/bin/env python}.
Całość pozwala na tworzenie wirtualnych środowisk ze specyficznymi wersjami Pythona, różnymi niż domyślny interpreter w systemie, jak również instalację odpowiednich bibliotek dla konkretnego projektu, a nie dla całego systemu.
Używanie wirtualnego środowiska nie wymaga również posiadania konta administratora.  
Wirtualne środowisko zwiększa również przenośność projektów.
Istnieje możliwość wyeksportowania do pliku tekstowego przy pomocy \texttt{PIP}-a listy zainstalowanych projektów wraz z ich wersjami.
Pozwala on również za zaimportowanie na nowym środowisku dokładnie tych samych bibliotek, co tworzy dokładną kopię środowiska źródłowego oraz ułatwia migrację aplikacji pomiędzy maszynami.
\subsection{Struktura}
Struktura Ansible jest bardzo prosta i skupia się na trzech podstawowych elementach. Są nimi:
\begin{itemize}
\item {inventory} - jest to plik zawierający listę hostów, które mają być zarządzane;
\item {moduły} - Ansible używa modułów w celu wykonywania konkretnych operacji. Pozwala to na pisanie własnych modułów;
\item {playbooki} - pliki zawierające całościowy opis stanu, jaki ma zostać osiągnięty na konfigurowanych hostach.
\end{itemize}
\subsubsection{Inventory}
Plik \textit{inventory} zawiera listę wszystkich hostów, które mogą znajdować się pod kontrolą Ansible.  
W każdej linijce pliku znajduje się definicja jednego hosta.
Format definicji hosta wygląda następująco:
\begin{lstlisting}
<hostname> [klucz1=wartosc1]...
\end{lstlisting}
\texttt{Hostname} jest nazwą wyświetlaną przez Ansible podczas generowania raportów, jak również nazwą, po której będzie próbował się łączyć do serwera.
Jeżeli \texttt{hostname} nie jest rozwiązywane przez używany serwer DNS, należy użyć specjalnej opcji, aby przekazać Ansible pod jakim adresem znajduje się dany serwer.
Poniżej podaję listę kilku najczęściej wykorzystywanych opcji. Pełna lista znajduje się w dokumentacji projektu Ansible.
\begin{description}
\item{ansible\_ssh\_host}\\
	określa adres IP, pod którym znajduje się dany serwer.	
\item{ansible\_ssh\_port}\\
	określa port, który ma zostać wykorzystany przy połączeniu. Przydatne, gdy serwer SSH działa na niestandardowym porcie.
\item{ansible\_ssh\_private\_key\_file}\\
	określa położenie klucza prywatnego używanego podczas połączenia. Użyteczne, gdy nie chcemy używać domyślnego klucza, bądź jeżeli któryś z serwerów ma inną bazę zaakceptowanych kluczy.
\end{description}
Dodatkowo, można zdefiniować swoje własne zmienne, które następnie mogą być wykorzystane przy ustalaniu parametrów modułów bądź w szablonach.  
Jak zostanie pokazane w kolejnych sekcjach pracy, definiowanie parametrów w pliku \texttt{inventory} nie jest zalecane.
Zalecanym sposobem definiowania zmiennych jest używanie \texttt{host\_vars}, co zostanie przedstawione w dalszej części.

Dopuszczalne jest również definiowanie hostów poprzez użycie zakresów zarówno liczbowych jak i znakowych.
Dla przykładu, dopuszczalne jest zdefiniowanie dwudziestu serwerów o nazwach \texttt{node01}, \texttt{node02} aż do \texttt{node20} poprzez poniższą definicję:
\begin{lstlisting}
node[01:50]
\end{lstlisting}
bądź \texttt{hostA} do \texttt{hostE}:
\begin{lstlisting}
host[A:F]
\end{lstlisting}

Istnieje również możliwość łączenia kilku hostów w grupy i późniejsze definiowanie zachowań w odniesieniu do grupy a nie każdego serwera osobo.
Grupa serwerów tworzona jest poprzez podanie w nawiasach kwadratowych nazwy grupy. Pod nią następuje standardowe listowanie serwerów.
Wszystkie serwery zdefiniowane po nazwie grupy a przed deklaracją następnej należą do grupy pierwszej.
W poniższym przykładzie utworzone zostaly trzy grupy hostów:
\lstinputlisting[caption=inventory]{lst/ansible_inventory}
Pierwsza grupa \texttt{centos} zawiera sześć węzłów i widzimy tutaj definiowanie hostów poprzez zakres.
Następna grupa \texttt{http} zawiera dwa hosty.
Ostatnia grupa jest jednoelementowa.
Można zauważyć, że jeden serwer może być członkiem więcej niż jednej grupy.

Została również zdefiniowana grupa \texttt{dc1}, której członkami są serwery należące do grup \texttt{http} oraz \texttt{haproxy}.
Widzimy więc, że można tworzyć również grupy składające się z innych grup.

Możliwe jest, chociaż również nie zalecane, zdefiniowanie zmiennych dla całej grupy.
Zmienne takie definiuje się w następujący sposób:
\begin{lstlisting}
[grupa1]
node1
node2
[grupa1:vars]
zmienna1=wartosc1
zmienna2=wartosc2
\end{lstlisting}
Jednak, podobnie jak w przypadku zmiennych ustawianych dla hostów, istnieje mechanizm \texttt{group\_vars} i jest on zalecanym mechanizmem ustawiania zmiennych dla grup.

Ostatnią interesującą rzeczą dotyczącą pliku \texttt{inventory} jest fakt, że plik ten nie musi być plikiem tekstowym, a może być skryptem wykonywalnym.
Ansible jest w stanie wykonać taki skrypt i jeśli zwrócona treść jest poprawnym formatem \texttt{inventory}, potraktuje to wyjście jako \texttt{inventory}.
\subsubsection{Moduły}
Ansible wyposażony jest w dużą gamę gotowych modułów.
Moduły w Ansible są to skrypty napisane w języku Python. Zwykle wykonują one jedną konkretną rzecz, do której zostały stworzone.
I tak na przykład mamy moduły:
\begin{description}
	\item{\textbf{users}} - służy do zarządzania użytkownikami w systemie. Pozwala on na tworzenie, usuwanie oraz modyfikowanie wszelkim parametrów użytkowników kont, takich jak np: katalog domowy, hasło czy domyślna powłoka, ale również pozwala na automatyczne wygenerowanie klucza ssh dla użytkownika podczas tworzenia konta.
	\item{\textbf{git}} - służy do zarządzania repozytoriami \texttt{gita}. Pozwala na klonowanie oraz aktualizację repozytorium \texttt{gita}. Daje możliwość wyboru gałęzi bądź \textit{commita}, na który ma być \textit{zdeployowana} aplikacja bądź wybór konkretnego pliku z kluczem ssh, który zostanie wykorzystany do połączenia.
	\item{\textbf{apt/yum/pip/portage/...}} - zestaw modułów pozwalających na zarządzanie oprogramowaniem na serwerze. Wspólną i najważniejszą opcją dla wszystkich modułów z tej grupy jest opcja \texttt{state}. Może ona przyjmować co najmniej trzy wartości \texttt{present/absent/latest}. Oznaczają one:
		\begin{itemize}
			\item{present} - jeżeli pakiet nie jest zainstalowany w systemie, to go zainstaluj. Jeżeli nie podano wersji, instalowana jest najnowsza.
				Natomiast jeżeli pakiet już jest w systemie to moduł zwraca komunikat "OK".
			\item{absent} - zasada odwrotna do stanu \textit{present}. Jeżeli pakiet jest zainstalowany, to zostanie on usunięty.
				A jeżeli nie było danego pakietu zainstalowanego w systemie, to moduł nie zrobi nic.
			\item{latest} - jest to stan bardziej skomplikowany niż dwa poprzednie, ponieważ w przypadku, gdy pakiet nie jest zainstalowany, następuje jego instalacja do wersji najnowszej.
				Natomiast, jeżeli pakiet jest już zainstalowany, sprawdzane jest czy zainstalowana wersja jest najnowszą dostępną w repozytorium.
				Jeżeli tak nie jest, to następuje aktualizacja pakietu do wersji najnowszej.
				
				Są to jedne z niewielu domyślnych modułów, których trzeba używać jawnie w zależności od dystrybucji systemu GNU/Linux na serwerze.
		\end{itemize}
	\item{\textbf{service}} - moduł zarządzający uruchamianiem usługami. Pozwala na zdefiniowanie poprzez parametr \texttt{enable} czy usługa powinna być uruchamiana przy starcie systemu.
		Drugim ważnym parametrem jest opcja \texttt{state}, która może przyjmować następujące wartości:
		\begin{itemize}
			\item{started} - upewnia się, że usługa jest uruchomiona. Jeżeli tak nie jest, uruchamia ją.
			\item{stoped} - upewnia się, że usługa jest zatrzymana. Jeżeli tak nie jest, zatrzymuje ją.
			\item{restarted} - przeprowadza procedurę restartu usługi niezależnie od jej aktualnego stanu.
			\item{reloaded} - przeładowuje daną usługę
		\end{itemize}
\end{description}

Powyżej zostało wymienionych tylko kilka z całej bogatej gamy modułów, jak również zostały one opisane tylko w najczęściej używanym zakresie.
Pełnej listy modułów oraz ich parametrów należy szukać w dokumentacji

\textit{Playbooki} zostaną opisane w osobnej sekcji.
\subsection{Użytkowanie}
\subsubsection{Tryb pracy Ad-Hoc}
Ansible pozwala na wywołanie konkretnego modułu z konkretnymi parametrami. W przeciwieństwie do opisywanych w kolejnej sekcji \textit{playbooków}, tryb Ad-Hoc przydaje się do szybkich jednorazowych operacji takich jak restart systemu bądź sprawdzenie aktualnych ustawień serwerów DNS na maszynach.
\lstinputlisting{lst/ansible_ad-hoc_resolve}
Na powyższym przykładzie widzimy wywołanie \textit{ad-hoc} polecenia \texttt{shell}, które wywołuje powłokę na zdalnej maszynie.
Polecenie zostało wywoływane dla grupy \texttt{all}, która oznacza, że należy wywołać polecenie dla wszystkich hostów zdefiniowanych w pliku \texttt{inventory}.
Parametrem podanym do modułu było polecenie \texttt{cat /etc/resolv.conf|grep nameserver}, które wypisuje adresy serwerów DNS używanych przez serwer.
Na wyjściu widzimy, że dla serwerół \texttt{mgr0-4} otrzymaliśmy linijki pliku \texttt{resolv.conf} zawierające adresy, natomiast dla pozostałych serwerów otrzymaliśmy informację, że nie udało się połączyć z nimi.
W tym przypadku było to spowodowane tym, że nie zostały one włączone.

Inny bardzo częstym zastosowaniem trybu \textit{ad-hoc} jest wgrywanie pliku na serwer zdalny.
Należy zaznaczyć, że z poniższego przykładu, celem zwiększenia czytelności, zostały usunięte komunikaty o błędach połączeń dla niewłączonych maszynoraz powtarzające się komunikaty o udanym wykonaniu polecenia na pozostałych hostach.
Należy również zaznaczyć, że hosty zostały wcześniej tak przygotowane, aby każdy zwrócił inny komunikat.
\lstinputlisting{lst/ansible_ad-hoc_copy}
Na powyższym przykładzie widzimy trzy możliwe stany wywołania polecenia:
\begin{description}
	\item{changed=true}\\
		Oznacza, że polecenie zakończyło się sukcesem oraz że podmiot operacji uległ zmianie. W tym przypadku oznacza to, że plik został wgrany na serwer i zmienił on stan.
		Zmianę stanu należy rozumieć jako utworzenie nowego pliku, zmianę jego treści, bądź któregoś z parametrów takich jak właściciel, prawa dostępu itp.
	\item{changed=false}\\
		Oznacza, że przeprowadzona operacja nie wprowadziła żadnych zmian do aktualnego stanu systemu.
		Jest to pożądany stan przy używaniu \textit{playbooków}, co zostanie opisane w następnej sekcji.
	\item{failed}\\
		Oznacza, że nie udało się wykonać polecenia.
		Często komunikat \texttt{failed} niesie ze sobą opis błędu zdefiniowany przez autora modułu lub przez system operacyjny.
\end{description}
Ostatnim modułem, o którym warto wspomnieć jest moduł \texttt{setup}. Uruchamiany jest poprzez polecenie:
\begin{lstlisting}
ansible <host> -m setup
\end{lstlisting}
Moduł ten służy do tzw. zbierania faktów, bądź audytu systemu pod kątem informacji o nim.
Niestety wyjście tego polecenia posiada ponad 200 linijek, dlatego nie zostanie ono tutaj załączone.
Moduł ten dostarcza informacji m.in. o:
\begin{itemize}
	\item adresach IP maszyny;
	\item architekturze;
	\item wersji jądra;
	\item dokładnych konfiguracji interface'ów sieciowych;
	\item informacji o dyskach twardych: podziale na partycje, sektorach przypadających na partycje, rozmiarze sektora;
	\item dystrybucji systemu;
	\item konfiguracji sprzętowej
\end{itemize}
oraz wielu innych nie wspomnianych powyżej.
\subsubsection{Playbook}
Głównym celem używania Ansible nie jest jednokrotne wywoływanie poleceń opisane w poprzednim przykładzie, lecz utrzymywanie stanu serwera w konkretnej konfiguracji.
Do opisu pożądanego stanu używane są tzw. \textit{playbooki}.
Definiują one stan w jakim ma się znaleźć system po ich wykonaniu.
I tak na przykład opisem stanu może być zdefiniowanie, że usłucha \texttt{apache2} ma być uruchomiona bądź, że pakiet \texttt{postfix} ma być zainstalowany w wersji $2.10.2-1$.
Wtedy, przy każdym wywołaniu \textit{playbooka} Ansible będzie sprawdzał czy te kryteria są spełnione i w przypadku, gdy któreś nie zostanie spełnione, ansible spróbuje doprowadzić system do stanu, kiedy kryterium będzie spełnione.

\textit{Playbooki} wykorzystują do pracy moduły. Te same moduły których możemy używać w trybie \textit{ad-hoc}.

Domyślnie, przed wykonaniem \textit{playbooka} następuje zebranie faktów o hostach, na których mają zostać wykonane operacje.
Zbieranie faktów odbywa się przy pomocy modułu \texttt{setup}, który został opisany w poprzedniej sekcji.
Dane, które zostaną zebrane mogę posłużyć zarówno do użycia ich w szablonach konfiguracji, jak również do podejmowania decyzji jakie operacje należy wykonać dla hosta. Jedną z najczęstszych decyzji, które są podejmowane na podstawie faktów, jest podział systemów na rodziny systemów operacyjnych.
Dla przykładu, systemy z rodziny \textit{Debian} używają menadżera pakietów \texttt{apt} natomiast rodzina \textit{Red Hat} \texttt{yum}-3.

\textit{Playbooki} oraz inne pliki wykorzystywane przez Ansible są zapisywane w formacie \textit{Yaml}.
Po dokładną specyfikację formatu \textit{Yaml} odsyłam do dokumentacji.

Poniżej znajduje się przykładowy \textit{playbook}, na podstawie którego zostaną opisane najważniejsze jego elementy.
\lstinputlisting[caption=example\_playbook.yml]{lst/ansible_playbook_simple.yml}
Zwyczajowo pliki \texttt{yaml} zaczynają się się od trzech znaków myślnika.
Potem następuje określenie grupy hostów, na których należy wykonać aktualnego \textit{playbooka}.
W tym przypadku, jest to grupa \texttt{wwww}.
Należy tutaj zaznaczyć, że taka grupa musi zostać zdefiniowana w pliku \texttt{inventory}.
W następnej kolejności możemy zdefiniować dodatkowe zmienne.
Zmienne ustawione w \textit{playbooku} mają wyższy priorytet, niż te zdefiniowane w \texttt{host\_vars}, dlatego istnieje możliwość stworzenia \textit{playbooka} dla środowiska developerskiego nadpisującego parametry używane na środowisku produkcyjnym.

Kolejną, najważniejszą sekcją, jest zdefiniowanie operacji, które ma wykonać \textit{playbook}.
Składa się ona z nazwy, która jest nieobowiązkowa i służy jedynie podaniu informacji o tym, co w danej chwili robi \textit{playbook} oraz informacji z modułu z parametrami.
Moduły używane w \textit{playbooku} są tymi samymi modułami, które były używane w trybie \textit{ad-hoc}.

Istnieje możliwość zdefiniowania opcjonalnej sekcji \texttt{notify} w definicji zadania. Jej zadaniem jest wykonanie jakiejś operacji tylko w przypadku, gdy efektem wykonania zadania będzie stan \texttt{changed}.
Na załączonym przykładzie widzimy, że na zdalny serwer jest wgrywany plik konfiguracyjne do dazy MySQL.
Plik jest tworzony na podstawie szablonu przy użyciu silnika \textit{jinja2}.
Opcja \textit{notify} sprawia, że jeżeli nowy plik konfiguracyjny różni się od obecnego, następuje ponowne uruchomienie bazy danych.
Dzięki temu nie ma potrzeby restartowania bazy danych przy każdym uruchomieniu \textit{playbooka} oraz w przypadku zmiany konfiguracji, efekty są zauważalne od razu.

Podczas gdy w trybie \textit{ad-hoc} wykonanie jakieś modułu miało na celu wykonanie jakiejś operacji oraz zmianę stanu serwera, tak w przypadku \textit{playbooków} dąży się, aby wywołanie zwracało jak najwięcej stanów \texttt{ok} oraz jak najmniej \textit{changed}.
Stan \texttt{ok} oznacza, że stan serwera jest zgodny z naszymi założeniami i nie ma potrzeby podejmować żadnych kroków.
Stan \texttt{changed} pojawia się w przypadku zmian w konfiguracji jakiś usług, bądź w przypadku ingerencji manualnej administratora lub nieoczekiwanego zachowania aplikacji, np: wystąpienia błędu powodującego wyłączenie się aplikacj.

Uruchomienie \textit{playbooka} następuje poprzez polecenie \texttt{ansible-playbook} oraz podanie jako parametru nazwy pliku zawierającego konfigurację żądanego \textit{playbooka}.
Dodatkowo, do wywołania można dodać parametry sterujące wykonywaniem \textit{playbooka}, m.in. liczbę równoległych połączeń, wskazać plik \texttt{inventory} bądź ograniczyć wykonywane \textit{taski} tylko do tych oznaczonych określonymi \textit{tagami}.
\subsubsection{Role}
Jak łatwo zauważyć, w poprzednim przykładzie wykonaliśmy cztery operacje angażujące dwie grupy serwerów a plik zawierał 23 linijki kodu.
Można w prosty sposób estymować, że rzeczywisty \textit{playbook} będzie tych linii zawierał kilkaset bądź więcej, co sprawi ze jego czytanie i utrzymywanie stanie się bardzo trudne, jeśli nie niemożliwe.
Dlatego wprowadzono mechanizm ról.
Jest to zalecana forma definicji stanu poszczególnych typów serwerów.
Role pozwalają na separacje zadań, zmiennych, plików, szablonów i innych.
Pozwala to również na migrowanie definicji ról pomiędzy systemami.

Definicje ról znajdują się w katalogu \texttt{roles}, w którym występują podkatalogi o nazwie roli.
W każdym katalogu z rolą może znajdować się od jednego do sześciu katalogów odpowiadających za poszczególne elementy roli.
Poniżej przedstawione jest przykładowe drzewo zawierające dwie role.
\lstinputlisting{lst/ansible_roles_tree}
Ansible, podczas ładowania roli, sprawdza po kolei czy istnieją powyższe katalogi.
Jeżeli katalog istnieje, sprawdzane jest czy istnieje w nim plik \texttt{main.yml} (nie dotyczy to katalogów \texttt{files} oraz \texttt{templates}) i jeżeli istnieje, jego zawartość zostaje załączona do \textit{playbooka}.
potem następuje wywołanie dyrektywy \texttt{include}, która pobiera zawartość pliku i wstawia w miejsce, w którym została wywołana.\\
Znaczenie poszczególnych katalogów jest następujące:
\begin{description}
	\item{\texttt{files}} - w katalogu tym powinny znaleźć się wszystkie pliki, które dana rola będzie kopiowała na serwer zdalny.
		Umieszczenie plików w tym katalogu daje możliwość podania do modułu kopiującego jedynie nazwy pliku źródłowego zamiast pełnej ścieżki dostępu. Np:
		\begin{lstlisting}
- name: kopiowanie issue.net
- copy: src=issue.net dest=/etc/issue.net
		\end{lstlisting}
		zamiast
		\begin{lstlisting}
- name: kopiowanie issue.net
- copy: src=/home/admin/ansible/all_files/issue.net dest=/etc/issue.net
		\end{lstlisting}
		Trzeba mieć na uwadze, że niejeden administrator zamiast zrobić kopię pliku w katalogu z rolą, utworzy katalog zbiorczy ze wszystkimi plikami.
		W znacznym stopniu może to utrudnić migrację definicji takiej roli, ponieważ oprócz katalogu z jej definicją, należy przenieść ze wspólnego katalogu wszystkie pliki dotyczące tej roli.
		Użycie katalogu \texttt{files} wewnątrz katalogu roli, rozwiązuje ten problem, ponieważ przekopiowanie katalogu z rolą, zapewnia pełną kompatybilność niezależnie od systemu.
	\item{\texttt{templates}} - znajdują się tu wszystkie definicje szablonów, których może używać rola.
		Tego katalogu tyczą się wszystkie zastrzeżenia dotyczące katalogu \texttt{files}.

		Ansible korzysta z silnika \textit{jinja2}, który jest wzorowany na silniku szablonów wykorzystywanym we frameworku Django.\\
		Szablony pozwalają na wykorzystywanie obu wartości zmiennych.
		Zmienne te można podać w pliku \textit{inventory} (zostało to opisane wcześniej w sekcji \texttt{vars} w \textit{playbooku}), bądź w plikach przygotowanych do tego celu.
		
		Pierwszym miejscem, gdzie można umieszczać zmienne są katalogi \texttt{host\_vars} oraz \texttt{group\_vars}, które należy utworzyć w katalogu głównym \textit{playbooka}.
		Wewnątrz nich tworzy się pliki odpowiednio: z nazwami hostów bądź z nazwami grup.
W przypadku \texttt{host\_vars} host o nazwie zgodniej z nazwą pliku, będzie zawierał zmienne w nim zdefiniowane, natomiast w przypadku \texttt{group\_vars}, wszystkie hosty należące do grupy zgodnej z nazwą pliku, zdefiniowane zmienne będą miały umieszczone w pliku.

		Przykładowy plik \texttt{host\_vars} definiujący port SSH, po którym Ansible powinien łączyć się do hosta:
		\lstinputlisting[caption=temida.yml]{lst/ansible_host_vars.yml}
		Natomiast poniższy przykład definiuje nazwę pakietu programu Apache2 oraz lokalizacje konfiguracji \textit{vhostów} dla systemu rodziny Debian.
		\lstinputlisting[caption=debian.yml]{lst/ansible_group_vars.yml}
		Drugim jest katalog \texttt{vars}, który zostanie wyjaśniony poniżej.
	\item{\texttt{Tasks}} - jest to katalog, w którym znajdują się definicje zadań, które należy wykonać dla danej roli.
		Jest to jedyny wymagany katalog w definicji roli.
		W katalogu tym powinien znaleźć się plik \texttt{main.yml}.
		Po odnalezieniu pliku \texttt{main.yml} następuje jego załączenie do \textit{playbooka}.
		Operację tą można przestawić w następujący sposób:
		\begin{lstlisting}
tasks:
 - include: tasks/main.yml
		\end{lstlisting}
		Powyższy przykład jest równoznaczny z wpisaniem zawartości tego pliku do sekcji \textit{tasks}, jednak pozwala na zachowanie czytelności kodu.\\
		Poniżej został przedstawiony przykładowy plik \texttt{tasks/main.yml}
		\lstinputlisting[caption=tasks/main.yml]{lst/ansible_tasks_main.yml}
		Widzimy, że powyższa rola upewnia się, że w systemie jest zainstalowana najnowsza wersja pakietu \texttt{libselinux-python}. Następnie moduł \texttt{copy}, kopiuje konfigurację dodatkowych repozytoriów na serwer zdalny.
		Pliki te znajdują się w katalogu \texttt{files}.
		Następnie widzimy użycie modułu \texttt{ini\_file} który jest w stanie edytować pliki konfiguracyjne.
		Po wskazaniu mu nazwy pliku oraz sekcji, następuje upewnienie się że opcja \texttt{enabled} ma ustawioną wrtość $1$.
		W przypadku, gdyby wartość była inna, bądź nie istniała, nastąpi jej dopisanie, tak, aby stan końcowy był zgodny z założonym.
	\item{\texttt{Handlers}} - w katalogu tym również umieszcza się plik \texttt{main.yml}, w którym dodaje się funkcje obsługujące wystąpienie statusu \texttt{changed}.
		Stosują się do niego wszystkie zastrzeżenia wymienione w sekcji o katalogu \texttt{tasks}.
		Przykładem takiego pliku jest ten zamieszczony poniżej:
		\lstinputlisting[caption=handlers/main.yml]{lst/ansible_handlers_main.yml}
		Widzimy tutaj definicję akcji o nazwie \textit{restart\_http}.
		Używa ona modułu \texttt{service}, który, jak zostało wspomniane wcześniej, obsługuje uruchamianie procesów.
		Jako nazwa występuje zmienna \texttt{apache}.
		Jest to zmienna zdefiniowana poprzednio w pliku \texttt{group\_vars} i oznacza nazwę usługi Apache pod systemem Debian.
	\item{\texttt{Vars}} - znajdują się w nim definicje zmiennych dotyczących roli.
		Podobnie jak w przypadku poprzednich katalogów następuje wyszukanie pliku \texttt{main.yml} oraz załadowanie go do sekcji \texttt{vars} w \textit{playbooku}.
	\item{\texttt{Meta}} - w tym katalogu znajdują się informacje o zależnościach pomiędzy rolami.
		Katalog zachowuje się jak \texttt{tasks}.
		Dla przykładu, tworząc role \texttt{apache2}, \texttt{mysql}, \texttt{php} oraz \texttt{lamp}, mamy możliwość w katalogu \texttt{meta} roli \texttt{lamp} zdefiniować zależności:
		\lstinputlisting[caption=meta/mail.yml]{lst/ansible_meta_main.yml}
		Efektem tego będzie, zastosowanie ról \texttt{apache2}, \texttt{mysql}, \texttt{php} na tym serwerze po przypisaniu do hosta roli \texttt{lamp}, przed wykonaniem zadań z tej roli.
		Powoduje to zmniejszenie rozmiaru \textit{playbooka}, jak również tworzenie \textit{playbooków} w duchu "co zrobić" a nie "jak zrobić".
		Definiujemy ze dane hosty mają mieć strukturę \textit{LAMP} bez podawania szczegółów jak należy to zrobić.
		Jest to niejako stworzenie dodatkowej warstwy abstrakcji pomiędzy wysokoideowymi \textit{playbookami} a niskoideowymi rolami.\\
		
\end{description}
